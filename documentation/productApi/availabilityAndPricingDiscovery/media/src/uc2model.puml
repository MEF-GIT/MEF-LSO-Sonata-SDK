@startuml
skinparam {
    ClassBackgroundColor White
    ClassBorderColor Black
}


enum ProductActionAddModifyType {

    add
    modify
}


class ProductRelationship {

    href: string
    id*: string
    relationshipType*: string
}



class Duration {

    amount*: integer
    units*: TimeUnit
}



enum TimeUnit {

    calendarMonths
    calendarDays
    calendarHours
    calendarMinutes
    businessDays
    businessHours
    businessMinutes
}
class RelatedPlaceRefOrValue {

    role*: string
    @type*: string
    @schemaLocation: uri
}



class FieldedAddress {

    country*: string
    streetType: string
    postcodeExtension: string
    city*: string
    streetNr: string
    locality: string
    postcode: string
    streetNrLast: string
    streetNrSuffix: string
    streetName*: string
    stateOrProvince: string
    streetNrLastSuffix: string
    streetSuffix: string
}
RelatedPlaceRefOrValue <|-- FieldedAddress

FieldedAddress *--> GeographicSubAddress : geographicSubAddress


class FormattedAddress {

    country*: string
    postcodeExtension: string
    stateOrProvince: string
    city*: string
    addrLine2: string
    addrLine1*: string
    locality: string
    postcode: string
}
RelatedPlaceRefOrValue <|-- FormattedAddress



class GeographicAddressLabel {

    externalReferenceId*: string
    externalReferenceType*: string
}
RelatedPlaceRefOrValue <|-- GeographicAddressLabel



class GeographicAddressRef {

    href: string
    id*: string
}
RelatedPlaceRefOrValue <|-- GeographicAddressRef



class GeographicSiteRef {

    href: string
    id*: string
}
RelatedPlaceRefOrValue <|-- GeographicSiteRef



class GeographicSubAddress {

    buildingName: string
    levelType: string
    levelNumber: string
    privateStreetNumber: string
    privateStreetName: string
}

GeographicSubAddress *-->"*" MEFSubUnit : subUnit


class MEFGeographicPoint {

    spatialRef*: string
    x*: string
    y*: string
    z: string
}
RelatedPlaceRefOrValue <|-- MEFGeographicPoint



class MEFSubUnit {

    subUnitNumber*: string
    subUnitType*: string
}


class ProductOfferingRef {

    href: string
    id*: string
}



class ProductRef {

    id*: string
    href: string
}



class PricingDiscovery_Common {

    action*: ProductActionAddModifyType
    productConfigurationIdentifier*: string
}

PricingDiscovery_Common *--> ProductRef : productRef
PricingDiscovery_Common *-->"*" ProductRelationship : productRelationship
PricingDiscovery_Common *-->"*" RelatedPlaceRefOrValue : place


class PricingDiscovery_Request {

}
PricingDiscovery_Common <|-- PricingDiscovery_Request



class PricingDiscovery {

}
PricingDiscovery_Common <|-- PricingDiscovery

PricingDiscovery *-->"*" PricingAndTerm : pricingAndTerms


class PricingAndTerm {
    identifier*: string
    subjectToAdditionalNonrecurringCharges*: boolean
    firm*: boolean
}

PricingAndTerm *-->"1" MEFItemTerm : term
PricingAndTerm *-->"1" TimePeriod : validFor
PricingAndTerm *-->"1..*" QuotePrice : price
PricingAndTerm *--> Duration : installationInterval
PricingAndTerm *-->"1" ProductOfferingRef : productOffering


class MEFItemTerm {

    endOfTermAction*: MEFEndOfTermAction
    name*: string
    description: string
}

MEFItemTerm *-->"1" Duration : duration
MEFItemTerm *--> Duration : rollInterval


enum MEFEndOfTermAction {

    roll
    autoDisconnect
    autoRenew
}
class TimePeriod {

    startDateTime: date-time
    endDateTime: date-time
}



class QuotePrice {

    unitOfMeasure: string
    name*: string
    priceType*: MEFPriceType
    description: string
    recurringChargePeriod: MEFChargePeriod
}

QuotePrice *-->"1" Price : price


enum MEFPriceType {

    recurring
    nonRecurring
    usageBased
}
enum MEFChargePeriod {

    hour
    day
    week
    month
    year
}
class Price {

    taxRate: float
}

Price *--> Money : taxIncludedAmount
Price *-->"1" Money : dutyFreeAmount


class Money {

    unit: string
    value: float
}



@enduml
